const Vulnerability = require('../models/Vulnerability');

// Get all vulnerabilities with filtering, sorting, and optimized cursor pagination
exports.getVulnerabilities = async (req, res) => {
  try {
    const {
      page = 1,
      limit = 50,
      severity,
      status,
      packageName,
      cve,
      sortBy = 'published',
      order = 'desc',
      cursor, // Cursor for efficient pagination
    } = req.query;

    const limitNum = parseInt(limit);
    const pageNum = parseInt(page);

    // Build filter object
    const filter = {};
    if (severity) filter.severity = severity.toLowerCase();
    if (status) filter.status = { $regex: status, $options: 'i' };
    if (packageName) filter.packageName = { $regex: packageName, $options: 'i' };
    if (cve) filter.cve = { $regex: cve, $options: 'i' };

    // Build sort object
    const sort = {};
    sort[sortBy] = order === 'asc' ? 1 : -1;
    sort._id = order === 'asc' ? 1 : -1; // Secondary sort by _id for consistency

    // Cursor-based pagination for better performance (when cursor is provided)
    let vulnerabilities;
    if (cursor) {
      filter._id = order === 'desc' ? { $lt: cursor } : { $gt: cursor };

      // Execute query with cursor pagination (no skip needed - more efficient!)
      vulnerabilities = await Vulnerability.find(filter)
        .sort(sort)
        .limit(limitNum + 1) // Fetch one extra to check if there's a next page
        .select('cve severity cvss status packageName packageVersion published fixDate')
        .lean();
    } else {
      // Fallback to offset-based pagination when no cursor (for random page access)
      const skip = (pageNum - 1) * limitNum;

      // Limit skip to reasonable values to prevent performance issues
      // For very large pages, MongoDB skip becomes extremely slow O(n)
      const MAX_SAFE_SKIP = 100000; // Skip max 100k documents
      if (skip > MAX_SAFE_SKIP) {
        return res.status(400).json({
          message: `Page ${pageNum} is too far. Please navigate sequentially using next/previous buttons for better performance, or jump to a page within the first ${Math.ceil(MAX_SAFE_SKIP / limitNum)} pages.`,
        });
      }

      vulnerabilities = await Vulnerability.find(filter)
        .sort(sort)
        .skip(skip)
        .limit(limitNum + 1) // Fetch one extra to check if there's a next page
        .select('cve severity cvss status packageName packageVersion published fixDate')
        .lean()
        .maxTimeMS(5000); // 5 second timeout
    }

    // Check if there are more results
    const hasMore = vulnerabilities.length > limitNum;
    const results = hasMore ? vulnerabilities.slice(0, limitNum) : vulnerabilities;

    // Get next cursor from the last item
    const nextCursor = hasMore ? results[results.length - 1]._id : null;

    // Calculate total count for pagination (required for page-based UI)
    // Only do this when not using cursor for better performance
    let totalCount = null;
    if (!cursor) {
      totalCount = await Vulnerability.countDocuments(filter);
    }

    res.json({
      vulnerabilities: results,
      pagination: {
        currentPage: pageNum,
        limit: limitNum,
        hasMore,
        nextCursor,
        totalCount,
      },
    });
  } catch (error) {
    res.status(500).json({ message: error.message });
  }
};

// Get vulnerability by ID
exports.getVulnerabilityById = async (req, res) => {
  try {
    const vulnerability = await Vulnerability.findById(req.params.id);

    if (!vulnerability) {
      return res.status(404).json({ message: 'Vulnerability not found' });
    }

    res.json(vulnerability);
  } catch (error) {
    res.status(500).json({ message: error.message });
  }
};

// Get dashboard statistics
exports.getDashboardStats = async (req, res) => {
  try {
    const [
      totalCount,
      severityStats,
      affectedRepos,
      fixedStats,
    ] = await Promise.all([
      // Total vulnerabilities
      Vulnerability.countDocuments(),

      // Count by severity
      Vulnerability.aggregate([
        {
          $group: {
            _id: '$severity',
            count: { $sum: 1 },
          },
        },
      ]),

      // Count affected repositories/packages
      Vulnerability.distinct('packageName'),

      // Fixed vulnerabilities
      Vulnerability.aggregate([
        {
          $group: {
            _id: null,
            total: { $sum: 1 },
            fixed: {
              $sum: {
                $cond: [
                  { $regexMatch: { input: '$status', regex: /fixed/i } },
                  1,
                  0,
                ],
              },
            },
          },
        },
      ]),
    ]);

    // Format severity stats
    const severityMap = severityStats.reduce((acc, item) => {
      acc[item._id] = item.count;
      return acc;
    }, {});

    // Calculate fix percentage
    const fixedPercentage = fixedStats.length > 0
      ? Math.round((fixedStats[0].fixed / fixedStats[0].total) * 100)
      : 0;

    res.json({
      total: totalCount,
      affectedRepositories: affectedRepos.length,
      fixedPercentage,
      severityBreakdown: {
        critical: severityMap.critical || 0,
        high: severityMap.high || 0,
        medium: severityMap.medium || 0,
        low: severityMap.low || 0,
      },
    });
  } catch (error) {
    res.status(500).json({ message: error.message });
  }
};

// Get vulnerabilities over time
exports.getVulnerabilitiesOverTime = async (req, res) => {
  try {
    const { months = 12 } = req.query;

    const startDate = new Date();
    startDate.setMonth(startDate.getMonth() - months);

    const timeline = await Vulnerability.aggregate([
      {
        $match: {
          published: { $gte: startDate },
        },
      },
      {
        $group: {
          _id: {
            year: { $year: '$published' },
            month: { $month: '$published' },
          },
          count: { $sum: 1 },
        },
      },
      {
        $sort: { '_id.year': 1, '_id.month': 1 },
      },
    ]);

    res.json(timeline);
  } catch (error) {
    res.status(500).json({ message: error.message });
  }
};

// Get risk factors summary (optimized with aggregation)
exports.getRiskFactors = async (req, res) => {
  try {
    // Use aggregation pipeline for better performance - processes data in MongoDB
    const riskFactors = await Vulnerability.aggregate([
      // Only process documents that have riskFactors
      {
        $match: {
          riskFactors: { $exists: true, $ne: null }
        }
      },
      // Convert the Map to an array of key-value pairs
      {
        $project: {
          riskFactorKeys: { $objectToArray: '$riskFactors' }
        }
      },
      // Unwind the array to create a document for each risk factor
      {
        $unwind: '$riskFactorKeys'
      },
      // Group by risk factor name and count occurrences
      {
        $group: {
          _id: '$riskFactorKeys.k',
          count: { $sum: 1 }
        }
      },
      // Sort by count descending
      {
        $sort: { count: -1 }
      },
      // Limit to top 10
      {
        $limit: 10
      },
      // Format the output
      {
        $project: {
          _id: 0,
          name: '$_id',
          count: 1
        }
      }
    ]);

    res.json(riskFactors);
  } catch (error) {
    res.status(500).json({ message: error.message });
  }
};
