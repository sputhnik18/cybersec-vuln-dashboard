const Vulnerability = require('../models/Vulnerability');

// Get all vulnerabilities with filtering, sorting, and pagination
exports.getVulnerabilities = async (req, res) => {
  try {
    const {
      page = 1,
      limit = 50,
      severity,
      status,
      packageName,
      cve,
      sortBy = 'published',
      order = 'desc',
    } = req.query;

    // Build filter object
    const filter = {};
    if (severity) filter.severity = severity;
    if (status) filter.status = { $regex: status, $options: 'i' };
    if (packageName) filter.packageName = { $regex: packageName, $options: 'i' };
    if (cve) filter.cve = { $regex: cve, $options: 'i' };

    // Build sort object
    const sort = {};
    sort[sortBy] = order === 'asc' ? 1 : -1;

    // Execute query with pagination
    const vulnerabilities = await Vulnerability.find(filter)
      .sort(sort)
      .limit(limit * 1)
      .skip((page - 1) * limit)
      .lean();

    // Get total count for pagination
    const count = await Vulnerability.countDocuments(filter);

    res.json({
      vulnerabilities,
      totalPages: Math.ceil(count / limit),
      currentPage: page,
      totalCount: count,
    });
  } catch (error) {
    res.status(500).json({ message: error.message });
  }
};

// Get vulnerability by ID
exports.getVulnerabilityById = async (req, res) => {
  try {
    const vulnerability = await Vulnerability.findById(req.params.id);

    if (!vulnerability) {
      return res.status(404).json({ message: 'Vulnerability not found' });
    }

    res.json(vulnerability);
  } catch (error) {
    res.status(500).json({ message: error.message });
  }
};

// Get dashboard statistics
exports.getDashboardStats = async (req, res) => {
  try {
    const [
      totalCount,
      severityStats,
      affectedRepos,
      fixedStats,
    ] = await Promise.all([
      // Total vulnerabilities
      Vulnerability.countDocuments(),

      // Count by severity
      Vulnerability.aggregate([
        {
          $group: {
            _id: '$severity',
            count: { $sum: 1 },
          },
        },
      ]),

      // Count affected repositories/packages
      Vulnerability.distinct('packageName'),

      // Fixed vulnerabilities
      Vulnerability.aggregate([
        {
          $group: {
            _id: null,
            total: { $sum: 1 },
            fixed: {
              $sum: {
                $cond: [
                  { $regexMatch: { input: '$status', regex: /fixed/i } },
                  1,
                  0,
                ],
              },
            },
          },
        },
      ]),
    ]);

    // Format severity stats
    const severityMap = severityStats.reduce((acc, item) => {
      acc[item._id] = item.count;
      return acc;
    }, {});

    // Calculate fix percentage
    const fixedPercentage = fixedStats.length > 0
      ? Math.round((fixedStats[0].fixed / fixedStats[0].total) * 100)
      : 0;

    res.json({
      total: totalCount,
      affectedRepositories: affectedRepos.length,
      fixedPercentage,
      severityBreakdown: {
        critical: severityMap.critical || 0,
        high: severityMap.high || 0,
        medium: severityMap.medium || 0,
        low: severityMap.low || 0,
      },
    });
  } catch (error) {
    res.status(500).json({ message: error.message });
  }
};

// Get vulnerabilities over time
exports.getVulnerabilitiesOverTime = async (req, res) => {
  try {
    const { months = 12 } = req.query;

    const startDate = new Date();
    startDate.setMonth(startDate.getMonth() - months);

    const timeline = await Vulnerability.aggregate([
      {
        $match: {
          published: { $gte: startDate },
        },
      },
      {
        $group: {
          _id: {
            year: { $year: '$published' },
            month: { $month: '$published' },
          },
          count: { $sum: 1 },
        },
      },
      {
        $sort: { '_id.year': 1, '_id.month': 1 },
      },
    ]);

    res.json(timeline);
  } catch (error) {
    res.status(500).json({ message: error.message });
  }
};

// Get risk factors summary
exports.getRiskFactors = async (req, res) => {
  try {
    const vulnerabilities = await Vulnerability.find({}, 'riskFactors').lean();

    const riskFactorCounts = {};

    vulnerabilities.forEach((vuln) => {
      if (vuln.riskFactors) {
        vuln.riskFactors.forEach((value, key) => {
          riskFactorCounts[key] = (riskFactorCounts[key] || 0) + 1;
        });
      }
    });

    const sortedRiskFactors = Object.entries(riskFactorCounts)
      .sort(([, a], [, b]) => b - a)
      .slice(0, 10)
      .map(([name, count]) => ({ name, count }));

    res.json(sortedRiskFactors);
  } catch (error) {
    res.status(500).json({ message: error.message });
  }
};
